import { useCallback, useRef } from 'react';
import { getNodeTypeFromEvent, normalizeEventType } from '@/helpers/flow/loopDetection';
import { generateSmartLabel } from '@/helpers/flow/nodeLabels';

/**
 * Custom hook to manage node creation from recorded events
 * Handles loop detection, text input merging, and auto-layout
 * 
 * @param {Object} config - Configuration
 * @param {Function} config.setNodes - Function to update nodes
 * @param {Function} config.setEdges - Function to update edges
 * @param {Function} config.setSelectedNode - Function to set selected node
 * @param {Function} config.setRecordedActions - Function to update recorded actions
 * @param {Function} config.setRecordedNodeCount - Function to update recorded node count
 * @param {Function} config.openLoopSubFlow - Function to open loop sub-flow modal
 * @param {Function} config.t - Translation function
 * @returns {Object} Node creation functions and refs
 */
export function useNodeCreation({
    setNodes,
    setEdges,
    setSelectedNode,
    setRecordedActions,
    setRecordedNodeCount,
    openLoopSubFlow,
    t,
}) {
    // Ref for loop detection - tracks consecutive similar actions
    const consecutiveActionsRef = useRef([]);

    // Get node type from event type
    const getNodeType = getNodeTypeFromEvent;

    /**
     * Create a Loop node from consecutive similar actions
     */
    const createLoopNodeFromActions = useCallback((actions, position) => {
        const loopNodeId = `loop_${Date.now()}`;
        const firstAction = actions[0];
        const actionLabel = firstAction.label || firstAction.eventType;

        // Create the action node for sub-flow
        const subFlowActionNode = {
            id: 'subflow-action-1',
            type: getNodeType(firstAction.eventType),
            position: { x: 200, y: 200 },
            data: {
                label: actionLabel,
                eventType: firstAction.eventType,
                resourceId: firstAction.resourceId,
                text: firstAction.text,
                screenshotUrl: firstAction.screenshotUrl,
                coordinates: firstAction.coordinates,
                bounds: firstAction.bounds,
                packageName: firstAction.packageName,
                className: firstAction.className,
                isRecorded: true,
            },
        };

        // Create sub-flow with loopStart -> action -> loopEnd
        const subFlow = {
            nodes: [
                {
                    id: 'loop-start',
                    type: 'loopStart',
                    data: { label: t('flows.editor.nodes.loop_start', 'Loop Start'), itemVariable: 'iteration' },
                    position: { x: 200, y: 50 },
                },
                subFlowActionNode,
                {
                    id: 'loop-end',
                    type: 'loopEnd',
                    data: { label: t('flows.editor.nodes.loop_end', 'Continue') },
                    position: { x: 200, y: 350 },
                },
            ],
            edges: [
                {
                    id: 'edge-start-action',
                    source: 'loop-start',
                    target: 'subflow-action-1',
                    type: 'animated',
                },
                {
                    id: 'edge-action-end',
                    source: 'subflow-action-1',
                    target: 'loop-end',
                    type: 'animated',
                },
            ],
        };

        // Create the Loop node
        const loopNode = {
            id: loopNodeId,
            type: 'loop',
            position: position,
            data: {
                label: `Loop: ${actionLabel} ×${actions.length}`,
                loopType: 'count',
                iterations: actions.length,
                itemVariable: 'iteration',
                indexVariable: 'index',
                subFlow: subFlow,
                isAutoGenerated: true,
                originalActionCount: actions.length,
                onEditSubFlow: (nodeId) => {
                    setSelectedNode(null);
                    openLoopSubFlow(nodeId);
                },
            },
        };

        return loopNode;
    }, [getNodeType, t, setSelectedNode, openLoopSubFlow]);

    /**
     * Smart Loop Detection: Create node from recorded event
     * Handles:
     * - Loop detection for repeated scroll/swipe actions
     * - Text input merging for continuous typing
     * - Auto-layout positioning
     * - Auto-connection to previous node
     */
    const createNodeFromEvent = useCallback((eventData, nodeSuggestion) => {
        const normalizedType = normalizeEventType(eventData.event_type);
        const LOOP_THRESHOLD = 3; // Create loop after 3 repeated actions

        // Event types that should NEVER be grouped into loops
        const LOOP_EXCLUDED_TYPES = [
            'text_input', 'set_text', 'focus', 'text_delete', 'open_app',
            'click', 'tap', 'double_tap', 'long_click', 'long_press'
        ];
        const shouldExcludeFromLoop = LOOP_EXCLUDED_TYPES.includes(normalizedType) ||
            LOOP_EXCLUDED_TYPES.includes(eventData.event_type);

        // Generate node ID first
        const newNodeId = `recorded_${Date.now()}_${eventData.sequence_number}`;

        // Access ref directly (not stale like state in closure)
        const currentConsecutive = consecutiveActionsRef.current;

        // Check if this action is similar to consecutive actions
        const resourceIdOrText = eventData.resource_id || eventData.resourceId || eventData.text || '';
        const firstActionResourceOrText = currentConsecutive[0]?.resourceId || currentConsecutive[0]?.text || '';

        // Compare coordinates for element-based actions
        const currentCoords = { x: eventData.x || 0, y: eventData.y || 0 };
        const firstActionCoords = currentConsecutive[0]?.coordinates || { x: 0, y: 0 };
        const COORD_TOLERANCE = 50;
        const isSamePosition = Math.abs(currentCoords.x - firstActionCoords.x) <= COORD_TOLERANCE &&
            Math.abs(currentCoords.y - firstActionCoords.y) <= COORD_TOLERANCE;

        const isElementBasedAction = ['click', 'tap', 'long_click', 'long_press', 'double_tap'].includes(normalizedType) ||
            ['click', 'tap', 'long_click', 'long_press', 'double_tap'].includes(eventData.event_type);

        const hasIdentifier = resourceIdOrText && firstActionResourceOrText;
        const identifiersMatch = !hasIdentifier || (resourceIdOrText === firstActionResourceOrText);
        const elementBasedMatch = isSamePosition && identifiersMatch;

        const isSimilarAction = !shouldExcludeFromLoop &&
            currentConsecutive.length > 0 &&
            normalizeEventType(currentConsecutive[0].eventType) === normalizedType &&
            (!isElementBasedAction || elementBasedMatch);

        // Build the new action object
        const smartLabel = generateSmartLabel(eventData);
        const newAction = {
            eventType: eventData.event_type,
            label: smartLabel,
            resourceId: eventData.resource_id || eventData.resourceId,
            text: eventData.text,
            screenshotUrl: eventData.screenshot_url || nodeSuggestion.data?.screenshotUrl,
            coordinates: { x: eventData.x, y: eventData.y },
            bounds: eventData.bounds,
            packageName: eventData.package_name,
            className: eventData.class_name,
            nodeId: newNodeId,
        };

        if (isSimilarAction) {
            // Add to consecutive actions
            const newConsecutiveActions = [...currentConsecutive, newAction];
            consecutiveActionsRef.current = newConsecutiveActions;

            // Check if we've reached the threshold
            if (newConsecutiveActions.length >= LOOP_THRESHOLD) {
                // Check if ANY Loop with same action type exists - MERGE into it
                setNodes(prevNodes => {
                    const existingLoop = prevNodes.find(node => {
                        if (node.type !== 'loop' || !node.data?.isAutoGenerated) return false;
                        const loopActionType = node.data.subFlow?.nodes?.find(n => n.type !== 'loopStart' && n.type !== 'loopEnd')?.data?.eventType;
                        const loopNormalizedType = loopActionType ? normalizeEventType(loopActionType) : null;
                        return loopNormalizedType === normalizedType;
                    });

                    const existingNodeIds = newConsecutiveActions
                        .slice(0, -1)
                        .map(a => a.nodeId)
                        .filter(Boolean);

                    if (existingLoop) {
                        // MERGE: Increase iterations of existing Loop
                        const newIterations = (existingLoop.data.iterations || 3) + newConsecutiveActions.length;

                        const updatedNodes = prevNodes
                            .filter(n => !existingNodeIds.includes(n.id))
                            .map(n =>
                                n.id === existingLoop.id
                                    ? {
                                        ...n,
                                        data: {
                                            ...n.data,
                                            iterations: newIterations,
                                            originalActionCount: newIterations,
                                            label: `Loop: ${n.data.label.split('×')[0].trim()} ×${newIterations}`,
                                        }
                                    }
                                    : n
                            );

                        setEdges(prevEdges =>
                            prevEdges.filter(e =>
                                !existingNodeIds.includes(e.source) && !existingNodeIds.includes(e.target)
                            )
                        );

                        setRecordedActions(prev =>
                            prev.filter(a => !existingNodeIds.includes(a.nodeId))
                        );

                        consecutiveActionsRef.current = [];
                        return updatedNodes;
                    }

                    // CREATE NEW LOOP
                    const firstNodeToRemove = prevNodes.find(n => n.id === existingNodeIds[0]);
                    const loopPosition = firstNodeToRemove?.position || { x: 400, y: 100 };

                    const loopNode = createLoopNodeFromActions(newConsecutiveActions, loopPosition);

                    const firstRemovedIndex = prevNodes.findIndex(n => n.id === existingNodeIds[0]);
                    const nodeBeforeLoop = firstRemovedIndex > 0 ? prevNodes[firstRemovedIndex - 1] : null;

                    const filtered = prevNodes.filter(n => !existingNodeIds.includes(n.id));

                    setEdges(prevEdges => {
                        const filteredEdges = prevEdges.filter(e =>
                            !existingNodeIds.includes(e.source) && !existingNodeIds.includes(e.target)
                        );
                        if (nodeBeforeLoop) {
                            const isLoopNode = nodeBeforeLoop.type === 'loop';
                            filteredEdges.push({
                                id: `edge_${nodeBeforeLoop.id}_${loopNode.id}`,
                                source: nodeBeforeLoop.id,
                                target: loopNode.id,
                                sourceHandle: isLoopNode ? 'complete' : undefined,
                                type: 'animated',
                                animated: true,
                            });
                        }
                        return filteredEdges;
                    });

                    setRecordedActions(prev => {
                        const filteredActions = prev.filter(a => !existingNodeIds.includes(a.nodeId));
                        return [...filteredActions, {
                            nodeId: loopNode.id,
                            eventType: 'loop',
                            label: loopNode.data.label,
                            timestamp: Date.now(),
                            isLoop: true,
                        }];
                    });

                    consecutiveActionsRef.current = [];
                    return [...filtered, loopNode];
                });

                return; // Don't create normal node
            }
        } else {
            if (shouldExcludeFromLoop) {
                consecutiveActionsRef.current = [];
            } else {
                consecutiveActionsRef.current = [newAction];
            }
        }

        // Create normal node with functional update
        setNodes(prevNodes => {
            const existingNodesCount = prevNodes.length;
            const lastNode = prevNodes[existingNodesCount - 1];

            // TEXT INPUT MERGING
            const isTextInput = eventData.event_type === 'text_input' || eventData.event_type === 'set_text';
            const eventResourceId = eventData.resource_id || eventData.resourceId || '';

            if (isTextInput && lastNode) {
                const lastNodeIsTextInput = lastNode.data?.eventType === 'text_input' || lastNode.data?.eventType === 'set_text';
                const lastNodeResourceId = lastNode.data?.resourceId || '';

                const isSameInputField = lastNodeIsTextInput && (
                    (eventResourceId && lastNodeResourceId && eventResourceId === lastNodeResourceId) ||
                    (!eventResourceId && !lastNodeResourceId &&
                        lastNode.data?.coordinates?.x === eventData.x &&
                        lastNode.data?.coordinates?.y === eventData.y)
                );

                if (isSameInputField) {
                    const newText = eventData.text || '';
                    const oldText = lastNode.data?.text || '';

                    if (newText !== oldText && newText.length >= oldText.length) {
                        return prevNodes.map(node =>
                            node.id === lastNode.id
                                ? {
                                    ...node,
                                    data: {
                                        ...node.data,
                                        text: newText,
                                        label: generateSmartLabel({ ...eventData, text: newText }),
                                        actionData: {
                                            ...node.data.actionData,
                                            text: newText,
                                        },
                                    }
                                }
                                : node
                        );
                    }
                    return prevNodes;
                }
            }

            // Auto-layout: position below last node
            const baseX = 400;
            const baseY = 100;
            const nodeHeight = 150;
            const gap = 80;

            let newY = baseY;
            if (lastNode && lastNode.position) {
                newY = lastNode.position.y + nodeHeight + gap;
            }

            const newNode = {
                id: newNodeId,
                type: getNodeType(eventData.event_type),
                position: { x: baseX, y: newY },
                data: {
                    label: nodeSuggestion.data?.label || eventData.event_type,
                    color: nodeSuggestion.data?.color || 'blue',
                    eventType: eventData.event_type,
                    resourceId: eventData.resource_id || eventData.resourceId,
                    text: eventData.text,
                    screenshotUrl: eventData.screenshot_url || nodeSuggestion.data?.screenshotUrl,
                    coordinates: { x: eventData.x, y: eventData.y },
                    bounds: eventData.bounds,
                    packageName: eventData.package_name,
                    className: eventData.class_name,
                    contentDescription: eventData.content_description,
                    actionData: eventData.action_data,
                    isRecorded: true,
                    sequenceNumber: eventData.sequence_number,
                },
            };

            // Auto-connect to previous node
            if (existingNodesCount > 0) {
                const isLoopNode = lastNode.type === 'loop';
                const edgeConfig = {
                    id: `edge_${lastNode.id}_${newNodeId}`,
                    source: lastNode.id,
                    target: newNodeId,
                    type: 'animated',
                    animated: true,
                };
                if (isLoopNode) {
                    edgeConfig.sourceHandle = 'complete';
                }
                setEdges(prevEdges => [...prevEdges, edgeConfig]);
            }

            return [...prevNodes, newNode];
        });

        setRecordedNodeCount(prev => prev + 1);

        // Track action for undo and history panel
        setRecordedActions(prev => [...prev, {
            nodeId: newNodeId,
            eventType: eventData.event_type,
            label: nodeSuggestion.data?.label || eventData.event_type,
            timestamp: Date.now(),
            screenshotUrl: eventData.screenshot_url,
        }]);
    }, [getNodeType, createLoopNodeFromActions, setNodes, setEdges, setRecordedActions, setRecordedNodeCount]);

    /**
     * Reset consecutive actions tracking (call when recording stops or on clear)
     */
    const resetConsecutiveActions = useCallback(() => {
        consecutiveActionsRef.current = [];
    }, []);

    return {
        // Functions
        createNodeFromEvent,
        createLoopNodeFromActions,
        resetConsecutiveActions,
        getNodeType,

        // Refs
        consecutiveActionsRef,
    };
}
